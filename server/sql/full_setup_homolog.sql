-- Create the combat_history table
create table if not exists combat_history (
  id bigint generated by default as identity primary key,
  character_id uuid references characters(id) not null,
  mob_id text not null,
  mob_name text,
  duration_seconds int,
  outcome text check (outcome in ('VICTORY', 'DEFEAT', 'FLEE')),
  xp_gained int default 0,
  silver_gained int default 0,
  loot_gained jsonb,
  damage_dealt int,
  damage_taken int,
  kills int default 0,
  occurred_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Index for querying by character
create index if not exists combat_history_character_id_idx on combat_history (character_id);


-- Create the dungeon_history table
create table if not exists dungeon_history (
  id bigint generated by default as identity primary key,
  character_id uuid references characters(id) not null,
  dungeon_id text not null,
  dungeon_name text,
  tier int,
  wave_reached int,
  max_waves int,
  duration_seconds int,
  outcome text check (outcome in ('COMPLETED', 'FAILED', 'ABANDONED')),
  xp_gained int default 0,
  silver_gained int default 0,
  loot_gained jsonb, -- Array of strings: ["2x T1_IRON", "1x T2_SWORD"]
  runs_completed int default 1,
  total_runs int default 1,
  occurred_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Index for querying by character
create index if not exists dungeon_history_character_id_idx on dungeon_history (character_id);


-- setup_friends_system.sql

-- 1. Create the friends table
CREATE TABLE IF NOT EXISTS public.friends (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    sender_id UUID NOT NULL REFERENCES public.characters(id) ON DELETE CASCADE,
    receiver_id UUID NOT NULL REFERENCES public.characters(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'PENDING', -- 'PENDING', 'ACCEPTED'
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    
    -- Prevent duplicate relationships
    CONSTRAINT unique_friendship UNIQUE(sender_id, receiver_id),
    -- Prevent friending yourself
    CONSTRAINT cannot_friend_self CHECK (sender_id <> receiver_id)
);

-- 2. Enable Row Level Security
ALTER TABLE public.friends ENABLE ROW LEVEL SECURITY;

-- 3. Create Policies
-- Users can see friendships where they are either the sender or receiver
CREATE POLICY "Users can view their own friendships"
ON public.friends
FOR SELECT
TO authenticated
USING (
    sender_id IN (SELECT id FROM public.characters WHERE user_id = auth.uid()) OR
    receiver_id IN (SELECT id FROM public.characters WHERE user_id = auth.uid())
);

-- Note: Inserts, Updates, and Deletes will be handled by the Server (Service Role) 
-- to ensure integrity and trigger socket notifications. 
-- Clients are Read-Only like the characters table.
REVOKE ALL ON public.friends FROM authenticated;
REVOKE ALL ON public.friends FROM anon;
GRANT SELECT ON public.friends TO authenticated;

-- 4. Create index for performance
CREATE INDEX IF NOT EXISTS idx_friends_sender ON public.friends(sender_id);
CREATE INDEX IF NOT EXISTS idx_friends_receiver ON public.friends(receiver_id);


-- Create the market_history table to track all sales
create table if not exists market_history (
    id bigint generated by default as identity primary key,
    item_id text not null,
    item_data jsonb not null,
    seller_id uuid references auth.users(id) not null,
    buyer_id uuid references auth.users(id) not null,
    seller_name text,
    buyer_name text,
    quantity bigint not null,
    price_total bigint not null,
    price_per_unit float8 not null,
    tax_paid bigint not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Index for global history (most recent first)
create index if not exists market_history_created_at_idx on market_history (created_at desc);

-- Index for item-specific history (trends)
create index if not exists market_history_item_id_idx on market_history (item_id);

-- Index for personal history (buying/selling)
create index if not exists market_history_seller_id_idx on market_history (seller_id, created_at desc);
create index if not exists market_history_buyer_id_idx on market_history (buyer_id, created_at desc);

-- Add description for introspection
comment on table market_history is 'Historical records of all completed marketplace transactions.';


-- Trade History Table
CREATE TABLE IF NOT EXISTS trade_history (
    id BIGSERIAL PRIMARY KEY,
    trade_id TEXT,
    sender_id UUID NOT NULL,
    receiver_id UUID NOT NULL,
    sender_name TEXT,
    receiver_name TEXT,
    sender_items JSONB DEFAULT '[]',
    sender_silver BIGINT DEFAULT 0,
    sender_tax BIGINT DEFAULT 0,
    receiver_items JSONB DEFAULT '[]',
    receiver_silver BIGINT DEFAULT 0,
    receiver_tax BIGINT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_trade_history_date ON trade_history(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_trade_history_sender ON trade_history(sender_id);
CREATE INDEX IF NOT EXISTS idx_trade_history_receiver ON trade_history(receiver_id);


-- TRADE SESSIONS TABLE
CREATE TABLE IF NOT EXISTS public.trade_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id UUID REFERENCES public.characters(id) ON DELETE CASCADE,
    receiver_id UUID REFERENCES public.characters(id) ON DELETE CASCADE,
    sender_offer JSONB DEFAULT '{"items": [], "silver": 0}'::jsonb,
    receiver_offer JSONB DEFAULT '{"items": [], "silver": 0}'::jsonb,
    sender_accepted BOOLEAN DEFAULT false,
    receiver_accepted BOOLEAN DEFAULT false,
    status TEXT DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'COMPLETED', 'CANCELLED')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- INDEXES
CREATE INDEX IF NOT EXISTS idx_trade_sender ON public.trade_sessions(sender_id);
CREATE INDEX IF NOT EXISTS idx_trade_receiver ON public.trade_sessions(receiver_id);
CREATE INDEX IF NOT EXISTS idx_trade_status ON public.trade_sessions(status);

-- RLS (Row Level Security)
ALTER TABLE public.trade_sessions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can see trades where they are either sender or receiver
DROP POLICY IF EXISTS "Users can view their own trades" ON public.trade_sessions;
CREATE POLICY "Users can view their own trades" ON public.trade_sessions
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.characters c
            WHERE c.user_id = auth.uid()
            AND (c.id = sender_id OR c.id = receiver_id)
        )
    );

-- Note: All writes (INSERT/UPDATE) must go through the Server (service_role)
-- to ensure strict validation of inventory, amounts, and the "Reset on Change" rule.

GRANT SELECT ON public.trade_sessions TO anon, authenticated;


-- Create World Boss Attempts table
CREATE TABLE IF NOT EXISTS world_boss_attempts (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    character_id UUID REFERENCES characters(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    damage BIGINT NOT NULL DEFAULT 0,
    claimed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(character_id, date)
);

-- Index for ranking queries
CREATE INDEX IF NOT EXISTS idx_wb_attempts_date_damage ON world_boss_attempts (date, damage DESC);

-- Enable RLS
ALTER TABLE world_boss_attempts ENABLE ROW LEVEL SECURITY;

-- Simple policy: authenticated users can read all (for ranking), but only insert/update their own
CREATE POLICY "Users can view all world boss attempts" ON world_boss_attempts
    FOR SELECT USING (true);

CREATE POLICY "Characters can insert their own attempts" ON world_boss_attempts
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM characters 
            WHERE id = character_id AND user_id = auth.uid()
        )
    );


CREATE TABLE IF NOT EXISTS user_sessions (
  user_id uuid PRIMARY KEY,
  last_active_at timestamp with time zone NOT NULL DEFAULT now()
);


-- 1. Create the new column
ALTER TABLE characters 
ADD COLUMN IF NOT EXISTS skills JSONB DEFAULT '{}'::jsonb;

-- 2. Migrate data from state->'skills' to the new 'skills' column
UPDATE characters 
SET skills = state->'skills'
WHERE state ? 'skills' AND (skills IS NULL OR skills = '{}'::jsonb);

-- 3. Remove 'skills' from the 'state' JSONB column
UPDATE characters 
SET state = state - 'skills'
WHERE state ? 'skills';


-- 1. Create the new column
ALTER TABLE characters 
ADD COLUMN IF NOT EXISTS equipment JSONB DEFAULT '{}'::jsonb;

-- 2. Migrate data from state->'equipment' to the new 'equipment' column
UPDATE characters 
SET equipment = state->'equipment'
WHERE state ? 'equipment' AND (equipment IS NULL OR equipment = '{}'::jsonb);

-- 3. Remove 'equipment' from the 'state' JSONB column
UPDATE characters 
SET state = state - 'equipment'
WHERE state ? 'equipment';


-- Add best friends columns to the friends table
ALTER TABLE public.friends 
ADD COLUMN IF NOT EXISTS is_best_friend BOOLEAN DEFAULT false;

ALTER TABLE public.friends 
ADD COLUMN IF NOT EXISTS best_friend_request_sender UUID REFERENCES public.characters(id) ON DELETE SET NULL;

-- Notify the community that friend system just got an upgrade! (Optional)
COMMENT ON COLUMN public.friends.is_best_friend IS 'Indicates if the two characters are best friends.';
COMMENT ON COLUMN public.friends.best_friend_request_sender IS 'Tracks which character sent a best friend request.';


ALTER TABLE user_sessions 
ADD COLUMN IF NOT EXISTS ip_address text;

-- Index for faster searching of alts
CREATE INDEX IF NOT EXISTS idx_user_sessions_ip ON user_sessions(ip_address);


-- Add player_name column to world_boss_attempts table
ALTER TABLE world_boss_attempts 
ADD COLUMN IF NOT EXISTS player_name TEXT;

-- Update existing records if possible (optional, might affect performance if table is huge)
UPDATE world_boss_attempts wba
SET player_name = c.name
FROM characters c
WHERE wba.character_id = c.id
AND wba.player_name IS NULL;


-- Query to find players using the same IP address (Multi-Accounting)

SELECT 
    us.ip_address, 
    COUNT(DISTINCT us.user_id) as account_count,
    -- List character names associated with these accounts
    array_agg(DISTINCT c.name) as character_names,
    -- List the user IDs for admin reference
    array_agg(DISTINCT us.user_id) as user_ids,
    -- Show when they were last active
    MAX(us.last_active_at) as last_seen
FROM user_sessions us
-- Join with characters to get readable names
JOIN characters c ON us.user_id = c.user_id
WHERE us.ip_address IS NOT NULL
-- Ignore localhost ipv6 for dev environments if needed, but useful to see
-- AND us.ip_address != '::1' 
GROUP BY us.ip_address
-- Only show IPs used by more than one account
HAVING COUNT(DISTINCT us.user_id) > 1
ORDER BY account_count DESC;


-- DIAGNOSTIC QUERY: List ALL user sessions without grouping
-- Use this to check if the first account is using a different IP (e.g., ::1 vs 127.0.0.1)

SELECT 
    us.user_id,
    c.name as character_name,
    us.ip_address,
    us.last_active_at
FROM user_sessions us
JOIN characters c ON us.user_id = c.user_id
ORDER BY us.last_active_at DESC;


-- SQL Migration: Add ON DELETE CASCADE to history tables character references

-- 1. combat_history
ALTER TABLE combat_history 
  DROP CONSTRAINT IF EXISTS combat_history_character_id_fkey,
  ADD CONSTRAINT combat_history_character_id_fkey 
    FOREIGN KEY (character_id) 
    REFERENCES characters(id) 
    ON DELETE CASCADE;

-- 2. dungeon_history
ALTER TABLE dungeon_history 
  DROP CONSTRAINT IF EXISTS dungeon_history_character_id_fkey,
  ADD CONSTRAINT dungeon_history_character_id_fkey 
    FOREIGN KEY (character_id) 
    REFERENCES characters(id) 
    ON DELETE CASCADE;

-- 3. world_boss_attempts (Already has it in schema, but ensuring for consistency)
ALTER TABLE world_boss_attempts 
  DROP CONSTRAINT IF EXISTS world_boss_attempts_character_id_fkey,
  ADD CONSTRAINT world_boss_attempts_character_id_fkey 
    FOREIGN KEY (character_id) 
    REFERENCES characters(id) 
    ON DELETE CASCADE;


-- SQL Reference for Integer Overflow Fix
-- Execute this in Supabase SQL Editor if needed, or I will try to apply via code if possible.

-- 1. Market Listings
ALTER TABLE market_listings ALTER COLUMN amount TYPE BIGINT;
ALTER TABLE market_listings ALTER COLUMN price TYPE BIGINT;

-- 2. Combat History
ALTER TABLE combat_history ALTER COLUMN xp_gained TYPE BIGINT;
ALTER TABLE combat_history ALTER COLUMN silver_gained TYPE BIGINT;
ALTER TABLE combat_history ALTER COLUMN damage_dealt TYPE BIGINT;
ALTER TABLE combat_history ALTER COLUMN damage_taken TYPE BIGINT;

-- 3. Dungeon History
ALTER TABLE dungeon_history ALTER COLUMN xp_gained TYPE BIGINT;
ALTER TABLE dungeon_history ALTER COLUMN silver_gained TYPE BIGINT;
ALTER TABLE dungeon_history ALTER COLUMN duration_seconds TYPE BIGINT;

-- 4. Characters State (Optional investigation, but state is JSONB, which is safe)
-- However, it is good to ensure silver_gained in notifications is capped too.


-- SECURITY HARDENING: EXTRA TABLES
-- RUN THIS IN SUPABASE SQL EDITOR

-- 1. Secure Combat History
-- Client reads this via Socket (Server), so direct DB access is NOT needed.
ALTER TABLE "combat_history" ENABLE ROW LEVEL SECURITY;
REVOKE ALL ON "combat_history" FROM authenticated;
REVOKE ALL ON "combat_history" FROM anon;

-- 2. Secure Dungeon History
-- Client reads this via Socket (Server).
ALTER TABLE "dungeon_history" ENABLE ROW LEVEL SECURITY;
REVOKE ALL ON "dungeon_history" FROM authenticated;
REVOKE ALL ON "dungeon_history" FROM anon;

-- 3. Secure User Sessions
-- Server manages this via API.
ALTER TABLE "user_sessions" ENABLE ROW LEVEL SECURITY;
REVOKE ALL ON "user_sessions" FROM authenticated;
REVOKE ALL ON "user_sessions" FROM anon;

-- 4. Cleanup (Remove any old permissive policies if they exist)
DROP POLICY IF EXISTS "Enable read access for users based on user_id" ON "combat_history";
DROP POLICY IF EXISTS "Enable read access for users based on user_id" ON "dungeon_history";
DROP POLICY IF EXISTS "Enable read access for users based on user_id" ON "user_sessions";
DROP POLICY IF EXISTS "Public read access" ON "combat_history";
DROP POLICY IF EXISTS "Public read access" ON "dungeon_history";
DROP POLICY IF EXISTS "Public read access" ON "user_sessions";

DO $$
BEGIN
  RAISE NOTICE 'Extra Tables Locked Down: Clients have NO direct access.';
END
$$;


-- SECURITY HARDENING: MARKET & CHAT
-- RUN THIS IN SUPABASE SQL EDITOR

-- 1. Secure Market Listings
ALTER TABLE "market_listings" ENABLE ROW LEVEL SECURITY;

-- Revoke WRITE permissions (Only Server can list items)
REVOKE INSERT, UPDATE, DELETE ON "market_listings" FROM authenticated;
REVOKE INSERT, UPDATE, DELETE ON "market_listings" FROM anon;

-- Grant READ permission (Users need to see the market)
GRANT SELECT ON "market_listings" TO authenticated;

-- Create Policy for READ (If not exists)
DROP POLICY IF EXISTS "Public read market" ON "market_listings";
CREATE POLICY "Public read market" ON "market_listings" FOR SELECT TO authenticated USING (true);


-- 2. Secure Messages (Chat)
ALTER TABLE "messages" ENABLE ROW LEVEL SECURITY;

-- Revoke WRITE permissions (Only Server inserts messages for rate limiting/validation)
REVOKE INSERT, UPDATE, DELETE ON "messages" FROM authenticated;
REVOKE INSERT, UPDATE, DELETE ON "messages" FROM anon;

-- Grant READ permission (Users need to see chat)
GRANT SELECT ON "messages" TO authenticated;

-- Create Policy for READ
DROP POLICY IF EXISTS "Public read messages" ON "messages";
CREATE POLICY "Public read messages" ON "messages" FOR SELECT TO authenticated USING (true);

DO $$
BEGIN
  RAISE NOTICE 'Market & Chat Locked Down: Clients can READ but only Server can WRITE.';
END
$$;


-- SECURITY HARDENING: THE NUCLEAR OPTION
-- RUN THIS IN SUPABASE SQL EDITOR

-- 1. Force Enable RLS (Just in case)
ALTER TABLE "public"."characters" ENABLE ROW LEVEL SECURITY;

-- 2. NUCLEAR REVOKE: Strip ALL permissions from the 'authenticated' (player) role
-- This overrides any specific policies that might try to grant access if the base permission is missing.
REVOKE INSERT, UPDATE, DELETE ON "public"."characters" FROM authenticated;
REVOKE INSERT, UPDATE, DELETE ON "public"."characters" FROM anon;

-- 3. GRANT READ-ONLY Access
-- Players can ONLY 'SELECT' (Read) data.
GRANT SELECT ON "public"."characters" TO authenticated;

-- 4. Clean Slate Policies
-- Remove ALL existing policies on this table to ensure no "allow-all" mistake remains.
DROP POLICY IF EXISTS "Users can read own characters" ON "public"."characters";
DROP POLICY IF EXISTS "Users can insert own characters" ON "public"."characters";
DROP POLICY IF EXISTS "Users can update own characters" ON "public"."characters";
DROP POLICY IF EXISTS "Users can delete own characters" ON "public"."characters";
DROP POLICY IF EXISTS "Enable read access for users based on user_id" ON "public"."characters";
DROP POLICY IF EXISTS "Enable insert for users based on user_id" ON "public"."characters";
DROP POLICY IF EXISTS "Enable update for users based on user_id" ON "public"."characters";
DROP POLICY IF EXISTS "Enable read access for all users" ON "public"."characters";
DROP POLICY IF EXISTS "Enable insert for all users" ON "public"."characters";
DROP POLICY IF EXISTS "Enable update for all users" ON "public"."characters";

-- 5. Create the ONLY Valid Policy: Read Your Own Data
CREATE POLICY "Users can only see their own characters"
ON "public"."characters"
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

-- 6. Verification Message
-- Only runs if using a client that supports returning messages, otherwise just completes.
DO $$
BEGIN
  RAISE NOTICE 'Security Hardening Complete: Clients are now READ-ONLY.';
END
$$;


